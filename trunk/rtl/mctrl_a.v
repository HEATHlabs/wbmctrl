//////////////////////////////////////////////////////////////////////////////////////////////
//
// Verilog file generated by X-HDL - Revision 3.2.37  Dec. 3, 2003 
// Sat Nov 24 10:44:57 2007
//
//      Input file         : D:/Downloads/gaisler/grlib-gpl-1.0.16-b2314/mctrl2/mctrl.vhd
//      Design name        : mctrl
//      Author             : 
//      Company            : 
//
//      Description        : 
//
//
//////////////////////////////////////////////////////////////////////////////////////////////
//
//--------------------------------------------------------------------------
//  This file is a part of the LEON VHDL model
//  Copyright (C) 1999  European Space Agency (ESA)
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or (at your option) any later version.
//
//  See the file COPYING.LGPL for the full details of the license.
//---------------------------------------------------------------------------
// Entity: 	mctrl
// File:	mctrl.vhd
// Author:	Jiri Gaisler - ESA/ESTEC
// Description:	External memory controller.
//----------------------------------------------------------------------------

//synopsys translate_off
`timescale 1ns / 1ps
//synopsys translate_on

module mctrl (
	rst, clk, 
	
	memi_data, memi_brdyn, memi_bexcn, memi_wrn, memi_bwidth,
	memi_sd,
	
	memo_address, memo_data, memo_sddata,	memo_ramsn, memo_ramoen, 
	memo_mben, memo_iosn, memo_romsn, memo_oen, memo_writen, memo_wrn,
	memo_bdrive, memo_vbdrive, memo_svbdrive, memo_read, memo_sa,
	
	ahbsi_hsel, ahbsi_haddr, ahbsi_hwrite, ahbsi_htrans, ahbsi_hsize, ahbsi_hburst,
	ahbsi_hwdata, ahbsi_hready, ahbsi_hmbsel,
	
	ahbso_hready,	ahbso_hresp, ahbso_hrdata, ahbso_hcache,
	
	apbi_psel, apbi_penable, apbi_paddr, apbi_pwrite, apbi_pwdata,
	
	apbo_prdata,
	
	wpo_wprothit,
	
	sdo_sdcke, sdo_sdcsn, sdo_sdwen, sdo_rasn, sdo_casn, sdo_dqm
	);

   parameter hindex  = 0;
   parameter pindex  = 0;
   parameter wprot  = 0;
   parameter invclk  = 0;
   parameter fast  = 0;
   parameter romasel  = 28;
   parameter sdrasel  = 29;
   parameter srbanks  = 5;
   parameter ram8  = 1;
   parameter ram16  = 1;
   parameter sden  = 1;
   parameter sepbus  = 0;
   parameter sdbits  = 32;
    // set to 12 for the GE-HPE board
   parameter sdlsb = 2;
   parameter oepol  = 0;
   parameter syncrst  = 0;
   parameter pageburst  = 0;
   `include "../include/amba.v"

   input rst; 
   input clk; 
   input[31:0] memi_data; 
   input memi_brdyn; 
   input memi_bexcn; 
   input[3:0] memi_wrn; 
   input[1:0] memi_bwidth; 
   input[63:0] memi_sd; 
   output[31:0] memo_address; 
   reg[31:0] memo_address;
   output[31:0] memo_data; 
   reg[31:0] memo_data;
   output[63:0] memo_sddata; 
   reg[63:0] memo_sddata;
   output[7:0] memo_ramsn; 
   reg[7:0] memo_ramsn;
   output[7:0] memo_ramoen; 
   reg[7:0] memo_ramoen;
   output[3:0] memo_mben; 
   reg[3:0] memo_mben;
   output memo_iosn; 
   reg memo_iosn;
   output[7:0] memo_romsn; 
   reg[7:0] memo_romsn;
   output memo_oen; 
   reg memo_oen;
   output memo_writen; 
   reg memo_writen;
   output[3:0] memo_wrn; 
   reg[3:0] memo_wrn;
   output[3:0] memo_bdrive; 
   reg[3:0] memo_bdrive;
   output[31:0] memo_vbdrive; 
   reg[31:0] memo_vbdrive;
   output[63:0] memo_svbdrive; 
   reg[63:0] memo_svbdrive;
   output memo_read; 
   reg memo_read;
   output[14:0] memo_sa; 
   reg[14:0] memo_sa;
   input[0:NAHBSLV - 1] ahbsi_hsel; 
   input[31:0] ahbsi_haddr; 
   input ahbsi_hwrite; 
   input[1:0] ahbsi_htrans; 
   input[2:0] ahbsi_hsize; 
   input[2:0] ahbsi_hburst; 
   input[31:0] ahbsi_hwdata; 
   input ahbsi_hready; 
   input[0:NAHBAMR - 1] ahbsi_hmbsel; 
   output ahbso_hready; 
   reg ahbso_hready;
   output[1:0] ahbso_hresp; 
   reg[1:0] ahbso_hresp;
   output[31:0] ahbso_hrdata; 
   reg[31:0] ahbso_hrdata;
   output ahbso_hcache; 
   reg ahbso_hcache;
   input[0:NAPBSLV - 1] apbi_psel; 
   input apbi_penable; 
   input[31:0] apbi_paddr; 
   input apbi_pwrite; 
   input[31:0] apbi_pwdata; 
   output[31:0] apbo_prdata; 
   reg[31:0] apbo_prdata;
   input wpo_wprothit; 
   output[1:0] sdo_sdcke; 
   reg[1:0] sdo_sdcke;
   output[1:0] sdo_sdcsn; 
   reg[1:0] sdo_sdcsn;
   output sdo_sdwen; 
   reg sdo_sdwen;
   output sdo_rasn; 
   reg sdo_rasn;
   output sdo_casn; 
   reg sdo_casn;
   output[7:0] sdo_dqm; 
   reg[7:0] sdo_dqm;

   parameter RAMSEL5 = srbanks == 5; 
   parameter SDRAMEN = (sden != 0); 
   parameter BUS16EN = (ram16 != 0); 
   parameter BUS8EN = (ram8 != 0); 
   parameter WPROTEN = (wprot != 0); 
   parameter WENDFB = 1'b0; 
   parameter SDSEPBUS = (sepbus != 0); 
   parameter BUS64 = (sdbits == 64); 
   parameter[2:0] idle = 0; 
   parameter[2:0] berr = 1; 
   parameter[2:0] bread = 2; 
   parameter[2:0] bwrite = 3; 
   parameter[2:0] bread8 = 4; 
   parameter[2:0] bwrite8 = 5; 
   parameter[2:0] bread16 = 6; 
   parameter[2:0] bwrite16 = 7; 
   // memory status register type
   // local registers
   reg[31:0] r_address; 
   reg[31:0] r_data; 
   reg[31:0] r_writedata; 
   reg[15:0] r_writedata8; 
   reg[63:0] r_sdwritedata; 
   reg[31:0] r_readdata; 
   reg r_brdyn; 
   reg r_ready; 
   reg r_ready8; 
   reg[3:0] r_bdrive; 
   reg[3:0] r_nbdrive; 
   reg[3:0] r_ws; 
   reg[1:0] r_romsn; 
   reg[4:0] r_ramsn; 
   reg[4:0] r_ramoen; 
   reg[1:0] r_size; 
   reg[1:0] r_busw; 
   reg r_oen; 
   reg[1:0] r_iosn; 
   reg r_read; 
   reg[3:0] r_wrn; 
   reg r_writen; 
   reg[2:0] r_bstate; 
   reg[0:2] r_area; 
   // memory configuration register 1 type
   reg[3:0] r_mcfg1_romrws; 
   reg[3:0] r_mcfg1_romwws; 
   reg[1:0] r_mcfg1_romwidth; 
   reg r_mcfg1_romwrite; 
   reg r_mcfg1_ioen; 
   reg[3:0] r_mcfg1_iows; 
   reg r_mcfg1_bexcen; 
   reg r_mcfg1_brdyen; 
   reg[1:0] r_mcfg1_iowidth; 
   // memory configuration register 2 type
   reg[1:0] r_mcfg2_ramrws; 
   reg[1:0] r_mcfg2_ramwws; 
   reg[1:0] r_mcfg2_ramwidth; 
   reg[3:0] r_mcfg2_rambanksz; 
   reg r_mcfg2_rmw; 
   reg r_mcfg2_brdyen; 
   reg r_mcfg2_srdis; 
   reg r_mcfg2_sdren; 
   reg r_bexcn; 
   reg r_echeck; 
   reg r_brmw; 
   reg[31:0] r_haddr; 
   reg r_hsel; 
   reg r_srhsel; 
   reg r_sdhsel; 
   reg r_hwrite; 
   reg[2:0] r_hburst; 
   reg[1:0] r_htrans; 
   reg[1:0] r_hresp; 
   reg[14:0] r_sa; 
   reg[63:0] r_sd; 
   reg[3:0] r_mben; 
   reg[31:0] ri_address; 
   reg[31:0] ri_data; 
   reg[31:0] ri_writedata; 
   reg[15:0] ri_writedata8; 
   reg[63:0] ri_sdwritedata; 
   reg[31:0] ri_readdata; 
   reg ri_brdyn; 
   reg ri_ready; 
   reg ri_ready8; 
   reg[3:0] ri_bdrive; 
   reg[3:0] ri_nbdrive; 
   reg[3:0] ri_ws; 
   reg[1:0] ri_romsn; 
   reg[4:0] ri_ramsn; 
   reg[4:0] ri_ramoen; 
   reg[1:0] ri_size; 
   reg[1:0] ri_busw; 
   reg ri_oen; 
   reg[1:0] ri_iosn; 
   reg ri_read; 
   reg[3:0] ri_wrn; 
   reg ri_writen; 
   reg[2:0] ri_bstate; 
   reg[0:2] ri_area; 
   reg[3:0] ri_mcfg1_romrws; 
   reg[3:0] ri_mcfg1_romwws; 
   reg[1:0] ri_mcfg1_romwidth; 
   reg ri_mcfg1_romwrite; 
   reg ri_mcfg1_ioen; 
   reg[3:0] ri_mcfg1_iows; 
   reg ri_mcfg1_bexcen; 
   reg ri_mcfg1_brdyen; 
   reg[1:0] ri_mcfg1_iowidth; 
   reg[1:0] ri_mcfg2_ramrws; 
   reg[1:0] ri_mcfg2_ramwws; 
   reg[1:0] ri_mcfg2_ramwidth; 
   reg[3:0] ri_mcfg2_rambanksz; 
   reg ri_mcfg2_rmw; 
   reg ri_mcfg2_brdyen; 
   reg ri_mcfg2_srdis; 
   reg ri_mcfg2_sdren; 
   reg ri_bexcn; 
   reg ri_echeck; 
   reg ri_brmw; 
   reg[31:0] ri_haddr; 
   reg ri_hsel; 
   reg ri_srhsel; 
   reg ri_sdhsel; 
   reg ri_hwrite; 
   reg[2:0] ri_hburst; 
   reg[1:0] ri_htrans; 
   reg[1:0] ri_hresp; 
   reg[14:0] ri_sa; 
   reg[63:0] ri_sd; 
   reg[3:0] ri_mben; 
   wire[16:2] sdmo_address; 
   wire sdmo_busy; 
   wire sdmo_aload; 
   wire sdmo_bdrive; 
   wire sdmo_hready; 
   wire sdmo_hsel; 
   wire sdmo_bsel; 
   wire[1:0] sdmo_hresp; 
   reg[31:0] sdi_haddr; 
   reg[31:0] sdi_rhaddr; 
   reg sdi_hready; 
   reg[1:0] sdi_hsize; 
   reg sdi_hsel; 
   reg sdi_hwrite; 
   reg[1:0] sdi_htrans; 
   reg[1:0] sdi_rhtrans; 
   reg[1:0] sdi_nhtrans; 
   reg sdi_idle; 
   reg sdi_enable; 
   reg sdi_srdis; 
   wire[31:0] sdapbo_prdata; 
   wire[1:0] lsdo_sdcke; 
   wire[1:0] lsdo_sdcsn; 
   wire lsdo_sdwen; 
   wire lsdo_rasn; 
   wire lsdo_casn; 
   wire[7:0] lsdo_dqm; 
   // vectored output enable to data pads 
   reg[31:0] rbdrive; 
   reg[31:0] ribdrive; 
   reg[63:0] rsbdrive; 
   reg[63:0] risbdrive; 
   // <<X-HDL>> Unsupported Construct - attribute  (source line 194)
   // <<X-HDL>> Unsupported Construct - attribute  (source line 195))
   // <<X-HDL>> Unsupported Construct - attribute  (source line 196))

   // **** tame: added signal to invert polarity
   // signal bprom_cs : std_ulogic;
   always @(*)
   begin : ctrl
   		reg[31:0] dataout; // data from memory
      reg[31:0] regsd; // data from registers
      reg[31:0] memdata; // data to memory
      reg[3:0] rws; // read waitstates
      reg[3:0] wws; // write waitstates
      reg[3:0] wsnew; // write waitstates
      reg[1:0] adec; 
      reg[4:0] rams; 
      reg bready; 
      reg leadin; 
      reg csen; // Generate chip selects
      reg[3:0] wrn; //
      reg addrerr; 
      reg ready; 
      reg[31:0] writedata; 
      reg[31:0] bwdata; 
      reg[2:0] merrtype; // memory error type
      reg noerror; 
      reg[0:2] area; 
      reg[3:0] bdrive; 
      reg[4:0] ramsn; 
      reg[1:0] romsn; 
      reg[1:0] busw; 
      reg iosn; 
      reg wprothitx; 
      reg brmw; 
      reg bidle; 
      reg[31:0] haddr; 
      reg[1:0] hsize; 
      reg hwrite; 
      reg[2:0] hburst; 
      reg[1:0] htrans; 
      reg sdhsel; 
      reg srhsel; 
      reg hready; 
      reg[31:0] vbdrive; 
      reg[63:0] vsbdrive; 
      reg[3:0] bdrive_sel; 
      // Variable default settings to avoid latches
		  ri_address=r_address;
		  ri_data=r_data;
		  ri_writedata=r_writedata;
		  ri_readdata=r_readdata;
		  ri_haddr=r_haddr;
			ri_writedata8=r_writedata8;
			ri_sdwritedata=r_sdwritedata;
			ri_sd=r_sd;
			ri_brdyn=r_brdyn;
			ri_ready=r_ready;
			ri_ready8=r_ready8;
			ri_oen=r_oen;
			ri_read=r_read;
			ri_writen=r_writen;
			ri_bexcn=r_bexcn;
			ri_echeck=r_echeck;
			ri_brmw=r_brmw;
			ri_bdrive=r_bdrive;
			ri_nbdrive=r_nbdrive;
			ri_ws=r_ws;
			ri_romsn=r_romsn;
			ri_size=r_size;
			ri_busw=r_busw;
			ri_iosn=r_iosn;
			ri_htrans=r_htrans;
			ri_hresp=r_hresp;
			ri_ramsn=r_ramsn;
			ri_ramoen=r_ramoen;
			ri_area=r_area;
			ri_hburst=r_hburst;
			ri_sa=r_sa;
			ri_bstate=r_bstate;
			ri_mcfg1_romrws=r_mcfg1_romrws;
			ri_mcfg1_romwws=r_mcfg1_romwws;
			ri_mcfg1_iows=r_mcfg1_iows;
			ri_mcfg1_romwidth=r_mcfg1_romwidth;
			ri_mcfg1_iowidth=r_mcfg1_iowidth;
			ri_mcfg1_romwrite=r_mcfg1_romwrite;
			ri_mcfg1_ioen=r_mcfg1_ioen;
			ri_mcfg1_bexcen=r_mcfg1_bexcen;
			ri_mcfg1_brdyen=r_mcfg1_brdyen;
			ri_mcfg2_ramrws=r_mcfg2_ramrws;
			ri_mcfg2_ramwws=r_mcfg2_ramwws;
			ri_mcfg2_ramwidth=r_mcfg2_ramwidth;
			ri_mcfg2_rambanksz=r_mcfg2_rambanksz;
			ri_mcfg2_rmw=r_mcfg2_rmw;
			ri_mcfg2_brdyen=r_mcfg2_brdyen;
			ri_mcfg2_srdis=r_mcfg2_srdis;
			ri_mcfg2_sdren=r_mcfg2_sdren;
			ri_wrn=r_wrn;
			ri_hsel=r_hsel;
			ri_srhsel=r_srhsel;
			ri_sdhsel=r_sdhsel;
			ri_hwrite=r_hwrite;
			ri_mben=r_mben;
			
      wprothitx = 1'b0; 
      ri_ready8 = 1'b0; 
      ri_iosn[0] = r_iosn[1]; 
      ready = 1'b0; 
      addrerr = 1'b0; 
      regsd = {32{1'b0}}; 
      csen = 1'b0; 
      ri_ready = 1'b0; 
      ri_echeck = 1'b0; 
      merrtype = 3'bxxx; 
      bready = 1'b1; 
      vbdrive = rbdrive; 
      vsbdrive = rsbdrive; 
      ri_data = memi_data; 
      ri_bexcn = memi_bexcn; 
      ri_brdyn = memi_brdyn; 
      if ((((r_brdyn & r_mcfg1_brdyen) == 1'b1) & ((r_area[mctrl_io]) == 1'b1)) | (((r_brdyn & r_mcfg2_brdyen) == 1'b1) & ((r_area[mctrl_ram]) == 1'b1) & ((r_ramsn[4]) == 1'b0) & RAMSEL5))
      begin
         bready = 1'b0; 
      end
      else
      begin
         bready = 1'b1; 
      end 
      ri_hresp = HRESP_OKAY; 
      if (SDRAMEN & (r_hsel == 1'b1) & (ahbsi_hready == 1'b0))
      begin
         haddr = r_haddr; 
         hsize = r_size; 
         hburst = r_hburst; 
         htrans = r_htrans; 
         hwrite = r_hwrite; 
         area = r_area; 
      end
      else
      begin
         haddr = ahbsi_haddr; 
         hsize = ahbsi_hsize[1:0]; 
         hburst = ahbsi_hburst; 
         htrans = ahbsi_htrans; 
         hwrite = ahbsi_hwrite; 
         area = ahbsi_hmbsel[0:2]; 
      end 
      if (SDRAMEN)
      begin
         if (fast == 1)
         begin
            sdhsel = ahbsi_hsel[hindex] & ahbsi_haddr[sdrasel] & ahbsi_htrans[1] & ahbsi_hmbsel[2]; 
         end
         else
         begin
            sdhsel = ahbsi_hsel[hindex] & ahbsi_htrans[1] & r_mcfg2_sdren & ahbsi_hmbsel[2] & (ahbsi_haddr[sdrasel] | r_mcfg2_srdis); 
         end 
         srhsel = ahbsi_hsel[hindex] & ~sdhsel; 
      end
      else
      begin
         sdhsel = 1'b0; 
         srhsel = ahbsi_hsel[hindex]; 
      end 
      // decode memory area parameters
      leadin = 1'b0; 
      rws = 4'bxxxx; 
      wws = 4'bxxxx; 
      adec = 2'bxx; 
      busw = {2{1'bx}}; 
      brmw = 1'b0; 
      if ((area[mctrl_rom]) == 1'b1)
      begin
         busw = r_mcfg1_romwidth; 
      end 
      if ((area[mctrl_ram]) == 1'b1)
      begin
         //adec = {genmux(r_mcfg2_rambanksz, haddr[sdrasel:14]), genmux(r_mcfg2_rambanksz, haddr[sdrasel - 1:13])}; 
         adec = {haddr[14+r_mcfg2_rambanksz],haddr[13+r_mcfg2_rambanksz]};
         if (sdhsel == 1'b1)
         begin
            busw = 2'b10; 
         end
         else
         begin
            busw = r_mcfg2_ramwidth; 
            if (((r_mcfg2_rmw & hwrite) == 1'b1) & ((BUS16EN & (busw == 2'b01) & (hsize == 2'b00)) | (((busw[1]) == 1'b1) & ((hsize[1]) == 1'b0))))
            begin
               brmw = 1'b1; 
            end // do a read-modify-write cycle
         end 
      end 
      if ((area[mctrl_io]) == 1'b1)
      begin
         leadin = 1'b1; 
         busw = r_mcfg1_iowidth; 
      end 
      if ((r_area[mctrl_rom]) == 1'b1)
      begin
         rws = r_mcfg1_romrws; 
         wws = r_mcfg1_romwws; 
         // decode waitstates, illegal access and cacheability
         if ((r_mcfg1_romwrite | r_read) == 1'b0)
         begin
            addrerr = 1'b1; 
         end 
      end 
      if ((r_area[mctrl_ram]) == 1'b1)
      begin
         rws = {2'b00, r_mcfg2_ramrws}; 
         wws = {2'b00, r_mcfg2_ramwws}; 
      end 
      if ((r_area[mctrl_io]) == 1'b1)
      begin
         rws = r_mcfg1_iows; 
         wws = r_mcfg1_iows; 
         if (r_mcfg1_ioen == 1'b0)
         begin
            addrerr = 1'b1; 
         end 
      end 
      // generate data buffer enables
      bdrive = {4{1'b1}}; 
      case (r_busw)
         2'b00 :
                  begin
                     if (BUS8EN)
                     begin
                        bdrive = 4'b0001; 
                     end 
                  end
         2'b01 :
                  begin
                     if (BUS16EN)
                     begin
                        bdrive = 4'b0011; 
                     end 
                  end
         default :
                  begin
                  end
      endcase 
      // generate chip select and output enable
//      rams = {1'b0, decode(adec)}; 
			case(adec)
				2'b00:	rams=5'b00001;
				2'b01:	rams=5'b00010;
				2'b10:	rams=5'b00100;
				2'b11:	rams=5'b01000;
			endcase			
      case (srbanks)
         0 :
                  begin
                     rams = 5'b00000; 
                  end
         1 :
                  begin
                     rams = 5'b00001; 
                  end
         2 :
                  begin
                     rams = {3'b000, (rams[3:2] | rams[1:0])}; 
                  end
         default :
                  begin
                     if (RAMSEL5 & ((haddr[sdrasel]) == 1'b1))
                     begin
                        rams = 5'b10000; 
                     end 
                  end
      endcase 
      iosn = 1'b1; 
      ramsn = {5{1'b1}}; 
      romsn = {2{1'b1}}; 
      if ((area[mctrl_rom]) == 1'b1)
      begin
         romsn = {(~haddr[romasel]), haddr[romasel]}; 
      end 
      if ((area[mctrl_ram]) == 1'b1)
      begin
         ramsn = ~rams; 
      end 
      if ((area[mctrl_io]) == 1'b1)
      begin
         iosn = 1'b0; 
      end 
      // generate write strobe
      wrn = 4'b0000; 
      case (r_busw)
         2'b00 :
                  begin
                     if (BUS8EN)
                     begin
                        wrn = 4'b1110; 
                     end 
                  end
         2'b01 :
                  begin
                     if (BUS16EN)
                     begin
                        if ((r_size == 2'b00) & (r_brmw == 1'b0))
                        begin
                           wrn = {2'b11, (~r_address[0]), r_address[0]}; 
                        end
                        else
                        begin
                           wrn = 4'b1100; 
                        end 
                     end 
                  end
         2'b10, 2'b11 :
                  begin
                     case (r_size)
                        2'b00 :
                                 begin
                                    case (r_address[1:0])
                                       2'b00 :
                                                begin
                                                   wrn = 4'b1110; 
                                                end
                                       2'b01 :
                                                begin
                                                   wrn = 4'b1101; 
                                                end
                                       2'b10 :
                                                begin
                                                   wrn = 4'b1011; 
                                                end
                                       default :
                                                begin
                                                   wrn = 4'b0111; 
                                                end
                                    endcase 
                                 end
                        2'b01 :
                                 begin
                                    wrn = {~r_address[1], ~r_address[1], r_address[1], r_address[1]}; 
                                 end
                        default :
                                 begin
                                 end
                     endcase 
                  end
         default :
                  begin
                  end
      endcase 
      if ((r_mcfg2_rmw == 1'b1) & ((r_area[mctrl_ram]) == 1'b1))
      begin
         wrn = ~bdrive; 
      end 
      if (((ahbsi_hready & ahbsi_hsel[hindex] & ahbsi_htrans[1]) == 1'b1))
      begin
         ri_area = area; 
         ri_address = haddr; 
         if ((busw == 2'b00) & (hwrite == 1'b0) & ((area[mctrl_io]) == 1'b0) & BUS8EN)
         begin
            ri_address[1:0] = 2'b00; 
         end 
         if ((busw == 2'b01) & (hwrite == 1'b0) & ((area[mctrl_io]) == 1'b0) & BUS16EN)
         begin
            ri_address[1:0] = 2'b00; 
         end 
         if (brmw == 1'b1)
         begin
            ri_read = 1'b1; 
         end
         else
         begin
            ri_read = ~hwrite; 
         end 
         ri_busw = busw; 
         ri_brmw = brmw; 
      end 
      if (((sdmo_aload & r_hsel) == 1'b1) & SDRAMEN)
      begin
         ri_address = haddr; 
         if ((busw == 2'b00) & (hwrite == 1'b0) & ((area[mctrl_io]) == 1'b0) & BUS8EN)
         begin
            ri_address[1:0] = 2'b00; 
         end 
         if ((busw == 2'b01) & (hwrite == 1'b0) & ((area[mctrl_io]) == 1'b0) & BUS16EN)
         begin
            ri_address[1:0] = 2'b00; 
         end 
      end 
      // Select read data depending on bus width
      if (BUS8EN & (r_busw == 2'b00))
      begin
         memdata = {r_readdata[23:0], r_data[31:24]}; 
      end
      else if (BUS16EN & (r_busw == 2'b01))
      begin
         memdata = {r_readdata[15:0], r_data[31:16]}; 
      end
      else
      begin
         memdata = r_data; 
      end 
      bwdata = memdata; 
      // Merge data during byte write
      writedata = ahbsi_hwdata; 
      if ((r_brmw & r_busw[1]) == 1'b1)
      begin
         case (r_address[1:0])
            2'b00 :
                     begin
                        writedata[15:0] = bwdata[15:0]; 
                        if (r_size == 2'b00)
                        begin
                           writedata[23:16] = bwdata[23:16]; 
                        end 
                     end
            2'b01 :
                     begin
                        writedata[31:24] = bwdata[31:24]; 
                        writedata[15:0] = bwdata[15:0]; 
                     end
            2'b10 :
                     begin
                        writedata[31:16] = bwdata[31:16]; 
                        if (r_size == 2'b00)
                        begin
                           writedata[7:0] = bwdata[7:0]; 
                        end 
                     end
            default :
                     begin
                        writedata[31:8] = bwdata[31:8]; 
                     end
         endcase 
      end 
      if ((r_brmw == 1'b1) & (r_busw == 2'b01) & BUS16EN)
      begin
         if ((r_address[0]) == 1'b0)
         begin
            writedata[23:16] = r_data[23:16]; 
         end
         else
         begin
            writedata[31:24] = r_data[31:24]; 
         end 
      end 
      // save read data during 8/16 bit reads
      if (BUS8EN & (r_ready8 == 1'b1) & (r_busw == 2'b00))
      begin
         ri_readdata = {ri_readdata[23:0], r_data[31:24]}; 
      end
      else if (BUS16EN & (r_ready8 == 1'b1) & (r_busw == 2'b01))
      begin
         ri_readdata = {ri_readdata[15:0], r_data[31:16]}; 
      end 
      // Ram, Rom, IO access FSM
      if (r_read == 1'b1)
      begin
         wsnew = rws; 
      end
      else
      begin
         wsnew = wws; 
      end 
      case (r_bstate)
         idle :
                  begin
                     ri_ws = wsnew; 
                     if ((r_bdrive[0]) == 1'b1)
                     begin
                        if ((r_busw[1]) == 1'b1)
                        begin
                           ri_writedata[31:16] = writedata[31:16]; 
                        end
                        else if (r_busw == 2'b01)
                        begin
                           if ((r_address[1]) == 1'b0)
                           begin
                              ri_writedata[31:16] = writedata[31:16]; 
                           end
                           else
                           begin
                              ri_writedata[31:16] = writedata[15:0]; 
                           end 
                        end
                        else
                        begin
                           case (r_address[1:0])
                              2'b00 :
                                       begin
                                          ri_writedata[31:16] = writedata[31:16]; 
                                       end
                              2'b01 :
                                       begin
                                          ri_writedata[31:24] = writedata[23:16]; 
                                       end
                              2'b10 :
                                       begin
                                          ri_writedata[31:16] = writedata[15:0]; 
                                       end
                              2'b11 :
                                       begin
                                          ri_writedata[31:24] = writedata[7:0]; 
                                       end
                              default :
                                       begin
                                       end
                           endcase 
                        end 
                        ri_writedata[15:0] = writedata[15:0]; 
                        if ((r_busw[1]) == 1'b0)
                        begin
                           ri_writedata8 = writedata[15:0]; 
                        end 
                     end 
                     if ((r_srhsel == 1'b1) & ((sdmo_busy == 1'b0) | ~SDRAMEN))
                     begin
                        if (WPROTEN)
                        begin
                           wprothitx = wpo_wprothit; 
                        end 
                        if ((wprothitx | addrerr) == 1'b1)
                        begin
                           ri_hresp = HRESP_ERROR; 
                           ri_bstate = berr; 
                           ri_bdrive = {4{1'b1}}; 
                        end
                        else if (r_read == 1'b0)
                        begin
                           if ((r_busw == 2'b00) & ((r_area[mctrl_io]) == 1'b0) & BUS8EN)
                           begin
                              ri_bstate = bwrite8; 
                           end
                           else if ((r_busw == 2'b01) & ((r_area[mctrl_io]) == 1'b0) & BUS16EN)
                           begin
                              ri_bstate = bwrite16; 
                           end
                           else
                           begin
                              ri_bstate = bwrite; 
                           end 
                           ri_wrn = wrn; 
                           ri_writen = 1'b0; 
                           ri_bdrive = ~bdrive; 
                        end
                        else
                        begin
                           if (r_oen == 1'b1)
                           begin
                              ri_ramoen = r_ramsn; 
                              ri_oen = 1'b0; 
                           end
                           else
                           begin
                              if ((r_busw == 2'b00) & ((r_area[mctrl_io]) == 1'b0) & BUS8EN)
                              begin
                                 ri_bstate = bread8; 
                              end
                              else if ((r_busw == 2'b01) & ((r_area[mctrl_io]) == 1'b0) & BUS16EN)
                              begin
                                 ri_bstate = bread16; 
                              end
                              else
                              begin
                                 ri_bstate = bread; 
                              end 
                           end 
                        end 
                     end 
                  end
         berr :
                  begin
                     ri_bstate = idle; 
                     ready = 1'b1; 
                     ri_hresp = HRESP_ERROR; 
                     ri_ramsn = {5{1'b1}}; 
                     ri_romsn = {2{1'b1}}; 
                     ri_ramoen = {5{1'b1}}; 
                     ri_oen = 1'b1; 
                     ri_iosn = 2'b11; 
                     ri_bdrive = {4{1'b1}}; 
                  end
         bread :
                  begin
                     if ((r_ws == 4'b0000) & (r_ready == 1'b0) & (bready == 1'b1))
                     begin
                        if (r_brmw == 1'b0)
                        begin
                           ready = 1'b1; 
                           ri_echeck = 1'b1; 
                           if ((r_area[mctrl_io]) == 1'b0)
                           begin
                              ri_address = ahbsi_haddr; 
                           end 
                        end 
                        if ((((ahbsi_hsel[hindex]) == 1'b0) | (ahbsi_htrans != HTRANS_SEQ)) | (r_hburst == HBURST_SINGLE) | ((r_area[mctrl_io]) == 1'b1))
                        begin
                           ri_ramoen = {5{1'b1}}; 
                           ri_oen = 1'b1; 
                           ri_iosn = 2'b11; 
                           ri_bstate = idle; 
                           ri_read = ~r_hwrite; 
                           if (r_brmw == 1'b0)
                           begin
                              ri_ramsn = {5{1'b1}}; 
                              ri_romsn = {2{1'b1}}; 
                           end
                           else
                           begin
                              ri_echeck = 1'b1; 
                           end 
                        end 
                     end 
                     if (r_ready == 1'b1)
                     begin
                        ri_ws = rws; 
                     end
                     else
                     begin
                        if (r_ws != 4'b0000)
                        begin
                           ri_ws = r_ws - 1; 
                        end 
                     end 
                  end
         bwrite :
                  begin
                     if ((r_ws == 4'b0000) & (bready == 1'b1))
                     begin
                        ready = 1'b1; 
                        ri_wrn = {4{1'b1}}; 
                        ri_writen = 1'b1; 
                        ri_echeck = 1'b1; 
                        ri_ramsn = {5{1'b1}}; 
                        ri_romsn = {2{1'b1}}; 
                        ri_iosn = 2'b11; 
                        ri_bdrive = {4{1'b1}}; 
                        ri_bstate = idle; 
                     end 
                     if (r_ws != 4'b0000)
                     begin
                        ri_ws = r_ws - 1; 
                     end 
                  end
         bread8 :
                  begin
                     if (BUS8EN)
                     begin
                        if ((r_ws == 4'b0000) & (r_ready8 == 1'b0) & (bready == 1'b1))
                        begin
                           ri_ready8 = 1'b1; 
                           ri_ws = rws; 
                           ri_address[1:0] = r_address[1:0] + 1; 
                           if (r_address[1:0] == 2'b11)
                           begin
                              ready = 1'b1; 
                              ri_address = ahbsi_haddr; 
                              ri_echeck = 1'b1; 
                              if ((((ahbsi_hsel[hindex]) == 1'b0) | (ahbsi_htrans != HTRANS_SEQ)) | (r_hburst == HBURST_SINGLE))
                              begin
                                 ri_ramoen = {5{1'b1}}; 
                                 ri_oen = 1'b1; 
                                 ri_iosn = 2'b11; 
                                 ri_bstate = idle; 
                                 ri_ramsn = {5{1'b1}}; 
                                 ri_romsn = {2{1'b1}}; 
                              end 
                           end 
                        end 
                        if (r_ready8 == 1'b1)
                        begin
                           ri_ws = rws; 
                        end
                        else if (r_ws != 4'b0000)
                        begin
                           ri_ws = r_ws - 1; 
                        end 
                     end
                     else
                     begin
                        ri_bstate = idle; 
                     end 
                  end
         bwrite8 :
                  begin
                     if (BUS8EN)
                     begin
                        if ((r_ws == 4'b0000) & (r_ready8 == 1'b0) & (bready == 1'b1))
                        begin
                           ri_ready8 = 1'b1; 
                           ri_wrn = {4{1'b1}}; 
                           ri_writen = 1'b1; 
                        end 
                        if ((r_ws == 4'b0000) & (bready == 1'b1) & ((r_address[1:0] == 2'b11) | ((r_address[1:0] == 2'b01) & (r_size == 2'b01)) | (r_size == 2'b00)))
                        begin
                           ready = 1'b1; 
                           ri_wrn = {4{1'b1}}; 
                           ri_writen = 1'b1; 
                           ri_echeck = 1'b1; 
                           ri_ramsn = {5{1'b1}}; 
                           ri_romsn = {2{1'b1}}; 
                           ri_iosn = 2'b11; 
                           ri_bdrive = {4{1'b1}}; 
                           ri_bstate = idle; 
                        end 
                        if (r_ready8 == 1'b1)
                        begin
                           ri_address[1:0] = r_address[1:0] + 1; 
                           ri_ws = rws; 
                           ri_writedata[31:16] = {r_writedata[23:16], r_writedata8[15:8]}; 
                           ri_writedata8[15:8] = r_writedata8[7:0]; 
                           ri_bstate = idle; 
                        end 
                        if (r_ws != 4'b0000)
                        begin
                           ri_ws = r_ws - 1; 
                        end 
                     end
                     else
                     begin
                        ri_bstate = idle; 
                     end 
                  end
         bread16 :
                  begin
                     if (BUS16EN)
                     begin
                        if ((r_ws == 4'b0000) & (bready == 1'b1) & ((r_address[1] | r_brmw) == 1'b1) & (r_ready8 == 1'b0))
                        begin
                           if (r_brmw == 1'b0)
                           begin
                              ready = 1'b1; 
                              ri_address = ahbsi_haddr; 
                              ri_echeck = 1'b1; 
                           end 
                           if ((((ahbsi_hsel[hindex]) == 1'b0) | (ahbsi_htrans != HTRANS_SEQ)) | (r_hburst == HBURST_SINGLE))
                           begin
                              if (r_brmw == 1'b0)
                              begin
                                 ri_ramsn = {5{1'b1}}; 
                                 ri_romsn = {2{1'b1}}; 
                              end 
                              ri_ramoen = {5{1'b1}}; 
                              ri_oen = 1'b1; 
                              ri_iosn = 2'b11; 
                              ri_bstate = idle; 
                              ri_read = ~r_hwrite; 
                           end 
                        end 
                        if ((r_ws == 4'b0000) & (bready == 1'b1) & (r_ready8 == 1'b0))
                        begin
                           ri_ready8 = 1'b1; 
                           ri_ws = rws; 
                           if (r_brmw == 1'b0)
                           begin
                              ri_address[1] = ~r_address[1]; 
                           end 
                        end 
                        if (r_ws != 4'b0000)
                        begin
                           ri_ws = r_ws - 1; 
                        end 
                     end
                     else
                     begin
                        ri_bstate = idle; 
                     end 
                  end
         bwrite16 :
                  begin
                     if (BUS16EN)
                     begin
                        if ((r_ws == 4'b0000) & (bready == 1'b1) & ((r_address[1:0] == 2'b10) | ((r_size[1]) == 1'b0)))
                        begin
                           ready = 1'b1; 
                           ri_wrn = {4{1'b1}}; 
                           ri_writen = 1'b1; 
                           ri_echeck = 1'b1; 
                           ri_ramsn = {5{1'b1}}; 
                           ri_romsn = {2{1'b1}}; 
                           ri_iosn = 2'b11; 
                           ri_bdrive = {4{1'b1}}; 
                           ri_bstate = idle; 
                        end 
                        if ((r_ws == 4'b0000) & (bready == 1'b1) & (r_ready8 == 1'b0))
                        begin
                           ri_ready8 = 1'b1; 
                           ri_wrn = {4{1'b1}}; 
                           ri_writen = 1'b1; 
                        end 
                        if (r_ready8 == 1'b1)
                        begin
                           ri_address[1] = ~r_address[1]; 
                           ri_ws = rws; 
                           ri_writedata[31:16] = r_writedata8[15:0]; 
                           ri_bstate = idle; 
                        end 
                        if (r_ws != 4'b0000)
                        begin
                           ri_ws = r_ws - 1; 
                        end 
                     end
                     else
                     begin
                        ri_bstate = idle; 
                     end 
                  end
         default :
                  begin
                  end
      endcase 
      if (ahbsi_hready == 1'b1)
      begin
         if (((ahbsi_hsel[hindex]) == 1'b0) | (ahbsi_htrans == HTRANS_BUSY) | (ahbsi_htrans == HTRANS_IDLE))
         begin
            ri_bstate = idle; 
            ri_ramsn = {5{1'b1}}; 
            ri_romsn = {2{1'b1}}; 
            ri_ramoen = {5{1'b1}}; 
            ri_oen = 1'b1; 
            ri_iosn = 2'b11; 
            ri_bdrive = {4{1'b1}}; 
            ri_wrn = {4{1'b1}}; 
            ri_writen = 1'b1; 
            ri_hsel = 1'b0; 
            ready = ahbsi_hsel[hindex]; 
            ri_srhsel = 1'b0; 
         end
         else if (srhsel == 1'b1)
         begin
            ri_romsn = romsn; 
            ri_ramsn[4:0] = ramsn[4:0]; 
            ri_iosn = {iosn, 1'b1}; 
            // if BUSY or IDLE cycle seen, or if de-selected, return to idle state
            if (ri_read == 1'b1)
            begin
               ri_ramoen[4:0] = ramsn[4:0]; 
               ri_oen = leadin; 
            end 
         end 
      end 
      // error checking and reporting
      noerror = 1'b1; 
      if ((r_echeck & r_mcfg1_bexcen & ~r_bexcn) == 1'b1)
      begin
         noerror = 1'b0; 
         ri_bstate = berr; 
         ri_hresp = HRESP_ERROR; 
         ri_bdrive = {4{1'b1}}; 
         ri_wrn = {4{1'b1}}; 
         ri_writen = 1'b1; 
      end 
      // APB register access
      case (apbi_paddr[3:2])
         2'b00 :
                  begin
                     regsd[28:0] = {r_mcfg1_iowidth, r_mcfg1_brdyen, r_mcfg1_bexcen, 1'b0, r_mcfg1_iows, 
                     		r_mcfg1_ioen, 1'b0, 6'b000000, r_mcfg1_romwrite, 1'b0, r_mcfg1_romwidth, r_mcfg1_romwws,
                     		r_mcfg1_romrws}; 
                  end
         2'b01 :
                  begin
                     if (SDRAMEN)
                     begin
                        regsd[31:17] = sdapbo_prdata[31:17]; 
                        if (BUS64)
                        begin
                           regsd[18] = 1'b1; 
                        end 
                        regsd[14:13] = {r_mcfg2_sdren, r_mcfg2_srdis}; 
                     end 
                     regsd[12:9] = r_mcfg2_rambanksz; 
                     if (RAMSEL5)
                     begin
                        regsd[7] = r_mcfg2_brdyen; 
                     end 
                     regsd[6:0] = {r_mcfg2_rmw, r_mcfg2_ramwidth, r_mcfg2_ramwws, r_mcfg2_ramrws}; 
                  end
         2'b10 :
                  begin
                     if (SDRAMEN)
                     begin
                        regsd[26:12] = sdapbo_prdata[26:12]; 
                     end 
                  end
         default :
                  begin
                     regsd = {32{1'b0}}; 
                  end
      endcase 
      //apbo_prdata <= regsd ; 
      apbo_prdata = regsd ; 
      if ((apbi_psel[pindex] & apbi_penable & apbi_pwrite) == 1'b1)
      begin
         case (apbi_paddr[5:2])
            4'b0000 :
                     begin
                        ri_mcfg1_romrws = apbi_pwdata[3:0]; 
                        ri_mcfg1_romwws = apbi_pwdata[7:4]; 
                        ri_mcfg1_romwidth = apbi_pwdata[9:8]; 
                        ri_mcfg1_romwrite = apbi_pwdata[11]; 
                        ri_mcfg1_ioen = apbi_pwdata[19]; 
                        ri_mcfg1_iows = apbi_pwdata[23:20]; 
                        ri_mcfg1_bexcen = apbi_pwdata[25]; 
                        ri_mcfg1_brdyen = apbi_pwdata[26]; 
                        ri_mcfg1_iowidth = apbi_pwdata[28:27]; 
                     end
            4'b0001 :
                     begin
                        ri_mcfg2_ramrws = apbi_pwdata[1:0]; 
                        ri_mcfg2_ramwws = apbi_pwdata[3:2]; 
                        ri_mcfg2_ramwidth = apbi_pwdata[5:4]; 
                        ri_mcfg2_rmw = apbi_pwdata[6]; 
                        ri_mcfg2_brdyen = apbi_pwdata[7]; 
                        ri_mcfg2_rambanksz = apbi_pwdata[12:9]; 
                        if (SDRAMEN)
                        begin
                           ri_mcfg2_srdis = apbi_pwdata[13]; 
                           ri_mcfg2_sdren = apbi_pwdata[14]; 
                        end 
                     end
            default :
                     begin
                     end
         endcase 
      end 
      if ((r_area[mctrl_rom] | r_area[mctrl_ram]) == 1'b1)
      begin
         dataout = memdata; 
      end
      else
      begin
         // select appropriate data during reads
         if (BUS8EN & (r_busw == 2'b00))
         begin
            dataout = {r_data[31:24], r_data[31:24], r_data[31:24], r_data[31:24]}; 
         end
         else if (BUS16EN & (r_busw == 2'b01))
         begin
            dataout = {r_data[31:16], r_data[31:16]}; 
         end
         else
         begin
            dataout = r_data; 
         end 
      end 
      ri_ready = ready; 
      ri_srhsel = r_srhsel & ~ready; 
      if (ahbsi_hready == 1'b1)
      begin
         ri_hsel = ahbsi_hsel[hindex]; 
      end 
      if ((ahbsi_hready & ahbsi_hsel[hindex]) == 1'b1)
      begin
         ri_size = ahbsi_hsize[1:0]; 
         ri_hwrite = ahbsi_hwrite; 
         ri_hburst = ahbsi_hburst; 
         ri_htrans = ahbsi_htrans; 
         if ((ahbsi_htrans[1]) == 1'b1)
         begin
            ri_hsel = 1'b1; 
            ri_srhsel = srhsel; 
         end 
         if (SDRAMEN)
         begin
            ri_haddr = ahbsi_haddr; 
            ri_sdhsel = sdhsel; 
         end 
      end 
      if (SDRAMEN)
      begin
         ri_sa = sdmo_address; 
         ri_sd = memi_sd; 
         if ((r_bstate != idle) | (({r_ramsn, r_romsn, r_iosn}) != 9'b111111111))
         begin
            bidle = 1'b0; 
         end
         else
         begin
            bidle = 1'b1; 
            if ((sdmo_busy & ~sdmo_aload) == 1'b1)
            begin
               // sdram synchronisation
               if (~SDSEPBUS)
               begin
                  ri_address[sdlsb + 14:sdlsb] = sdmo_address; 
               end 
               ri_romsn = {2{1'b1}}; 
               ri_ramsn[4:0] = {5{1'b1}}; 
               ri_iosn = {2{1'b1}}; 
               ri_ramoen[4:0] = {5{1'b1}}; 
               ri_oen = 1'b1; 
               ri_bdrive = ~({sdmo_bdrive, sdmo_bdrive, sdmo_bdrive, sdmo_bdrive}); 
               if (r_sdhsel == 1'b1)
               begin
                  ri_hresp = sdmo_hresp; 
               end 
            end 
         end 
         if ((sdmo_aload & r_srhsel) == 1'b1)
         begin
            ri_romsn = romsn; 
            ri_ramsn[4:0] = ramsn[4:0]; 
            ri_iosn = {iosn, 1'b1}; 
            if (ri_read == 1'b1)
            begin
               ri_ramoen[4:0] = ramsn[4:0]; 
               ri_oen = leadin; 
            end 
         end 
         if (sdmo_hsel == 1'b1)
         begin
            ri_writedata = writedata; 
            ri_sdwritedata[31:0] = writedata; 
            if (BUS64 & sdmo_bsel == 1'b1)
            begin
               ri_sdwritedata[63:32] = writedata; 
            end 
            hready = sdmo_hready & noerror & ~r_brmw; 
            if (SDSEPBUS)
            begin
               if (BUS64 & sdmo_bsel == 1'b1)
               begin
                  dataout = r_sd[63:32]; 
               end
               else
               begin
                  dataout = r_sd[31:0]; 
               end 
            end 
         end
         else
         begin
            hready = r_ready & noerror; 
         end 
      end
      else
      begin
         hready = r_ready & noerror; 
      end 
      if (ri_read == 1'b1)
      begin
         ri_mben = 4'b0000; 
      end
      else
      begin
         ri_mben = ri_wrn; 
      end 
      ri_nbdrive = ~ri_bdrive; 
      if (oepol == 0)
      begin
         bdrive_sel = r_bdrive; 
         vbdrive[31:24] = {8{ri_bdrive[0]}}; 
         vbdrive[23:16] = {8{ri_bdrive[1]}}; 
         vbdrive[15:8] = {8{ri_bdrive[2]}}; 
         vbdrive[7:0] = {8{ri_bdrive[3]}}; 
         vsbdrive[31:24] = {8{ri_bdrive[0]}}; 
         vsbdrive[23:16] = {8{ri_bdrive[1]}}; 
         vsbdrive[15:8] = {8{ri_bdrive[2]}}; 
         vsbdrive[7:0] = {8{ri_bdrive[3]}}; 
         vsbdrive[63:56] = {8{ri_bdrive[0]}}; 
         vsbdrive[55:48] = {8{ri_bdrive[1]}}; 
         vsbdrive[47:40] = {8{ri_bdrive[2]}}; 
         vsbdrive[39:32] = {8{ri_bdrive[3]}}; 
      end
      else
      begin
         bdrive_sel = r_nbdrive; 
         vbdrive[31:24] = {8{ri_nbdrive[0]}}; 
         vbdrive[23:16] = {8{ri_nbdrive[1]}}; 
         vbdrive[15:8] = {8{ri_nbdrive[2]}}; 
         vbdrive[7:0] = {8{ri_nbdrive[3]}}; 
         vsbdrive[31:24] = {8{ri_nbdrive[0]}}; 
         vsbdrive[23:16] = {8{ri_nbdrive[1]}}; 
         vsbdrive[15:8] = {8{ri_nbdrive[2]}}; 
         vsbdrive[7:0] = {8{ri_nbdrive[3]}}; 
         vsbdrive[63:56] = {8{ri_nbdrive[0]}}; 
         vsbdrive[55:48] = {8{ri_nbdrive[1]}}; 
         vsbdrive[47:40] = {8{ri_nbdrive[2]}}; 
         vsbdrive[39:32] = {8{ri_nbdrive[3]}}; 
      end 
      if (rst == 1'b0)
      begin
         ri_bstate = idle; 
         ri_read = 1'b1; 
         ri_wrn = 4'b1111; 
         ri_writen = 1'b1; 
         ri_mcfg1_romwrite = 1'b0; 
         ri_mcfg1_ioen = 1'b0; 
         ri_mcfg1_brdyen = 1'b0; 
         ri_mcfg1_bexcen = 1'b0; 
         ri_hsel = 1'b0; 
         ri_srhsel = 1'b0; 
         ri_ready = 1'b1; 
         ri_mcfg1_iows = 4'b0000; 
         ri_mcfg2_ramrws = 2'b00; 
         ri_mcfg2_ramwws = 2'b00; 
         ri_mcfg1_romrws = 4'b1111; 
         ri_mcfg1_romwws = 4'b1111; 
         ri_mcfg1_romwidth = memi_bwidth; 
         ri_mcfg2_srdis = 1'b0; 
         ri_mcfg2_sdren = 1'b0; 
         if (syncrst == 1)
         begin
            ri_ramsn = {5{1'b1}}; 
            ri_romsn = {2{1'b1}}; 
            ri_oen = 1'b1; 
            ri_iosn = 2'b11; 
            ri_ramoen = {5{1'b1}}; 
            ri_bdrive = {4{1'b1}}; 
            ri_nbdrive = {4{1'b0}}; 
            // reset
            if (oepol == 0)
            begin
               vbdrive = {32{1'b1}}; 
               vsbdrive = {64{1'b1}}; 
            end
            else
            begin
               vbdrive = {32{1'b0}}; 
               vsbdrive = {64{1'b0}}; 
            end 
         end 
      end 
      if (oepol == 0)
      begin
         // optional feeb-back from write stobe to data bus drivers
         if (WENDFB)
         begin
            bdrive = r_bdrive & memi_wrn; 
         end
         else
         begin
            bdrive = r_bdrive; 
         end 
      end
      else
      begin
         if (WENDFB)
         begin
            bdrive = r_nbdrive | ~memi_wrn; 
         end
         else
         begin
            bdrive = r_nbdrive; 
         end 
      end 
      //synopsys translate_off
      begin : xhdl_1
         integer i;
         for(i = 31; i >= 0; i = i - 1)
         begin
            //'
            if (dataout[i]===1'bx)
            begin
               dataout[i] = 1'b1; 
            end 
         end
      end 
      //synopsys translate_on
      // drive various register inputs and external outputs
      //ri = v ; 
      ribdrive = vbdrive ; 
      risbdrive = vsbdrive ; 
      ahbso_hcache = ~r_area[mctrl_io] ; 
      memo_address = r_address ; 
      memo_ramsn = {3'b111, r_ramsn} ; 
      memo_ramoen = {3'b111, r_ramoen} ; 
      memo_romsn = {6'b111111, r_romsn} ; 
      memo_oen = r_oen ; 
      memo_iosn = r_iosn[0] ; 
      memo_read = r_read ; 
      memo_wrn = r_wrn ; 
      memo_writen = r_writen ; 
      memo_bdrive = bdrive ; 
      memo_data = r_writedata ; 
      memo_mben = r_mben ; 
      memo_vbdrive = rbdrive ; 
      sdi_idle = bidle ; 
      sdi_haddr = haddr ; 
      sdi_rhaddr = r_haddr ; 
      sdi_nhtrans = htrans ; 
      sdi_rhtrans = r_htrans ; 
      sdi_htrans = ahbsi_htrans ; 
      sdi_hready = ahbsi_hready ; 
      sdi_hsize = r_size ; 
      sdi_hwrite = r_hwrite ; 
      sdi_hsel = sdhsel ; 
      sdi_enable = r_mcfg2_sdren ; 
      sdi_srdis = r_mcfg2_srdis ; 
      ahbso_hrdata = dataout ; 
      ahbso_hready = hready ; 
      ahbso_hresp = r_hresp ; 
   end 

   always @(posedge clk)
   begin : stdregs
      {r_address, r_data, r_writedata, r_writedata8, r_sdwritedata, r_readdata, r_brdyn,
       r_ready, r_ready8, r_bdrive, r_nbdrive, r_ws, r_romsn, r_ramsn, r_ramoen, r_size, 
       r_busw, r_oen, r_iosn, r_read, r_wrn, r_writen, r_bstate, r_area, r_mcfg1_romrws,
       r_mcfg1_romwws, r_mcfg1_romwidth, r_mcfg1_romwrite, r_mcfg1_ioen, r_mcfg1_iows, 
       r_mcfg1_bexcen, r_mcfg1_brdyen, r_mcfg1_iowidth, r_mcfg2_ramrws, r_mcfg2_ramwws,
       r_mcfg2_ramwidth, r_mcfg2_rambanksz, r_mcfg2_rmw, r_mcfg2_brdyen, r_mcfg2_srdis,
       r_mcfg2_sdren, r_bexcn, r_echeck, r_brmw, r_haddr, r_hsel, r_srhsel, r_sdhsel,
       r_hwrite, r_hburst, r_htrans, r_hresp, r_sa, r_sd, r_mben}
       <= {ri_address, ri_data, ri_writedata, ri_writedata8, ri_sdwritedata, ri_readdata, ri_brdyn,
       ri_ready, ri_ready8, ri_bdrive, ri_nbdrive, ri_ws, ri_romsn, ri_ramsn, ri_ramoen, ri_size,
       ri_busw, ri_oen, ri_iosn, ri_read, ri_wrn, ri_writen, ri_bstate, ri_area, ri_mcfg1_romrws,
       ri_mcfg1_romwws, ri_mcfg1_romwidth, ri_mcfg1_romwrite, ri_mcfg1_ioen, ri_mcfg1_iows,
       ri_mcfg1_bexcen, ri_mcfg1_brdyen, ri_mcfg1_iowidth, ri_mcfg2_ramrws, ri_mcfg2_ramwws,
       ri_mcfg2_ramwidth, ri_mcfg2_rambanksz, ri_mcfg2_rmw, ri_mcfg2_brdyen, ri_mcfg2_srdis,
       ri_mcfg2_sdren, ri_bexcn, ri_echeck, ri_brmw, ri_haddr, ri_hsel, ri_srhsel, ri_sdhsel,
       ri_hwrite, ri_hburst, ri_htrans, ri_hresp, ri_sa, ri_sd, ri_mben} ; 
      rbdrive <= ribdrive ; 
      rsbdrive <= risbdrive ; 
      if (rst == 1'b0)
      begin
         r_ws <= {4{1'b0}} ; 
      end  
      if ((syncrst == 0) & (rst == 1'b0))
      begin
         r_ramsn <= {5{1'b1}} ; 
         r_romsn <= {2{1'b1}} ; 
         r_oen <= 1'b1 ; 
         r_iosn <= 2'b11 ; 
         r_ramoen <= {5{1'b1}} ; 
         r_bdrive <= {4{1'b1}} ; 
         r_nbdrive <= {4{1'b0}} ; 
         if (oepol == 0)
         begin
            rbdrive <= {32{1'b1}} ; 
            rsbdrive <= {64{1'b1}} ; 
         end
         else
         begin
            rbdrive <= {32{1'b0}} ; 
            rsbdrive <= {64{1'b0}} ; 
         end 
      end 
   end 

// optional sdram controller
	generate
  if(SDRAMEN)
  begin:sd0
	    sdmctrl #(pindex, invclk, fast, wprot, sdbits, pageburst)
	    	sdctrl(
	    		.rst	(rst),
	    		.clk	(clk),
		      .sdi_idle			(sdi_idle), 
		      .sdi_haddr		(sdi_haddr), 
		      .sdi_rhaddr		(sdi_rhaddr), 
		      .sdi_nhtrans	(sdi_nhtrans), 
		      .sdi_rhtrans	(sdi_rhtrans), 
		      .sdi_htrans		(sdi_htrans), 
		      .sdi_hready		(sdi_hready), 
		      .sdi_hsize		(sdi_hsize), 
		      .sdi_hwrite		(sdi_hwrite), 
		      .sdi_hsel			(sdi_hsel), 
		      .sdi_enable		(sdi_enable), 
		      .sdi_srdis		(sdi_srdis),
		  		.sdo_sdcke		(lsdo_sdcke),
		  		.sdo_sdcsn		(lsdo_sdcsn),
		  		.sdo_sdwen		(lsdo_sdwen),
		  		.sdo_rasn			(lsdo_rasn),
		  		.sdo_casn			(lsdo_casn),
		  		.sdo_dqm			(lsdo_dqm),
		  		.apbi_psel		(apbi_psel),
		  		.apbi_penable	(apbi_penable),
		  		.apbi_paddr		(apbi_paddr),
		  		.apbi_pwrite	(apbi_pwrite),
		  		.apbi_pwdata	(apbi_pwdata),
		  		.apbo_prdata	(sdapbo_prdata),
		  		.wpo_wprothit	(wpo_wprothit),
		  		.sdmo_address	(sdmo_address),
				  .sdmo_busy		(sdmo_busy), 
				  .sdmo_aload		(sdmo_aload), 
				  .sdmo_bdrive	(sdmo_bdrive), 
				  .sdmo_hready	(sdmo_hready), 
				  .sdmo_hsel		(sdmo_hsel), 
				  .sdmo_bsel		(sdmo_bsel), 
				  .sdmo_hresp		(sdmo_hresp)
			);
		
		if(invclk == 0)
		begin:rgen
			always@(*)
			begin
	  		memo_sa = r_sa;
	  		sdo_sdcke=lsdo_sdcke;
	  		sdo_sdcsn=lsdo_sdcsn;
	  		sdo_sdwen=lsdo_sdwen;
	  		sdo_rasn=lsdo_rasn;
	  		sdo_casn=lsdo_casn;
	  		sdo_dqm=lsdo_dqm;
	  		memo_svbdrive = rsbdrive;
	    	memo_sddata[31 : 0]  = r_sdwritedata[31 : 0];
	    	memo_sddata[63 : 32] = r_sdwritedata[63 : 32];
	  	end
	  end
		else
		begin:ngen
	    always@(negedge clk)
	    begin
	      memo_sa <= r_sa; 
	  		sdo_sdcke <= lsdo_sdcke;
	  		sdo_sdcsn <= lsdo_sdcsn;
	  		sdo_sdwen <= lsdo_sdwen;
	  		sdo_rasn <= lsdo_rasn;
	  		sdo_casn <= lsdo_casn;
	  		sdo_dqm <= lsdo_dqm;
	      memo_svbdrive <= rsbdrive;
	    	memo_sddata[31 : 0]  <= r_sdwritedata[31 : 0];
	    	memo_sddata[63 : 32] <= r_sdwritedata[63 : 32];
	    end
	  end
  end
  endgenerate

	generate
	  if(!SDRAMEN)
	  begin:sd1
	  	assign sdapbo_prdata=32'b0; 
      assign sdmo_address = 15'b0;
      assign sdmo_busy = 1'b0;
      assign sdmo_aload = 1'b0;
      assign sdmo_bdrive = 1'b0;
      assign sdmo_hready = 1'b1;
      assign sdmo_hresp = 2'b11;
      assign sdmo_hsel=1'b0;
      assign sdmo_bsel=1'b0;
	  	always@(*)
	  	begin
	  		{sdo_sdcke, sdo_sdcsn, sdo_sdwen, sdo_rasn, sdo_casn, sdo_dqm}
	  			=15'b00_11_1_1_1_11111111;
				//sdmo <= ((others => '0'), '0', '0', '0', '1', '0', "11");   			
	  	end
		end
  endgenerate
endmodule
