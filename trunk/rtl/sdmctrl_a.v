//////////////////////////////////////////////////////////////////////////////////////////////
//
// Verilog file generated by X-HDL - Revision 3.2.37  Dec. 3, 2003 
// Sat Nov 24 10:44:40 2007
//
//      Input file         : D:/Downloads/gaisler/grlib-gpl-1.0.16-b2314/mctrl2/sdmctrl.vhd
//      Design name        : sdmctrl
//      Author             : 
//      Company            : 
//
//      Description        : 
//
//
//////////////////////////////////////////////////////////////////////////////////////////////
//
//----------------------------------------------------------------------------
//  This file is a part of the GRLIB VHDL IP LIBRARY
//  Copyright (C) 2003, Gaisler Research
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
//---------------------------------------------------------------------------
// Entity: 	sdmctrl
// File:	sdmctrl.vhd
// Author:	Jiri Gaisler - Gaisler Research
// Description:	SDRAM memory controller to fit with LEON2 memory controller.
//----------------------------------------------------------------------------

//synopsys translate_off
`timescale 1ns / 1ps
//synopsys translate_on

module sdmctrl (
	rst, clk,
	sdi_haddr, sdi_rhaddr, sdi_hready, sdi_hsize, sdi_hsel, sdi_hwrite, sdi_htrans,
	sdi_rhtrans, sdi_nhtrans, sdi_idle, sdi_enable, sdi_srdis,
	
	sdo_sdcke, sdo_sdcsn, sdo_sdwen, sdo_rasn, sdo_casn, sdo_dqm,
	
	apbi_psel, apbi_penable, apbi_paddr, apbi_pwrite, apbi_pwdata,
	
	apbo_prdata,
	
	wpo_wprothit,
	
	sdmo_address, sdmo_busy, sdmo_aload, sdmo_bdrive, sdmo_hready, sdmo_hsel, sdmo_bsel,
	sdmo_hresp
	);

   parameter pindex  = 0;
   parameter invclk  = 0;
   parameter fast  = 0;
   parameter wprot  = 0;
   parameter sdbits  = 32;
   parameter pageburst  = 0;
//   `include "memctrl.v"
//   `include "stdlib.v"
   `include "../include/amba.v"

   input rst; 
   input clk; 
   input[31:0] sdi_haddr; 
   input[31:0] sdi_rhaddr; 
   input sdi_hready; 
   input[1:0] sdi_hsize; 
   input sdi_hsel; 
   input sdi_hwrite; 
   input[1:0] sdi_htrans; 
   input[1:0] sdi_rhtrans; 
   input[1:0] sdi_nhtrans; 
   input sdi_idle; 
   input sdi_enable; 
   input sdi_srdis; 
   output[1:0] sdo_sdcke; 
   reg[1:0] sdo_sdcke;
   output[1:0] sdo_sdcsn; 
   reg[1:0] sdo_sdcsn;
   output sdo_sdwen; 
   reg sdo_sdwen;
   output sdo_rasn; 
   reg sdo_rasn;
   output sdo_casn; 
   reg sdo_casn;
   output[7:0] sdo_dqm; 
   reg[7:0] sdo_dqm;
   input[0:NAPBSLV - 1] apbi_psel; 
   input apbi_penable; 
   input[31:0] apbi_paddr; 
   input apbi_pwrite; 
   input[31:0] apbi_pwdata; 
   output[31:0] apbo_prdata; 
   reg[31:0] apbo_prdata;
   input wpo_wprothit; 
   output[16:2] sdmo_address; 
   reg[16:2] sdmo_address;
   output sdmo_busy; 
   reg sdmo_busy;
   output sdmo_aload; 
   reg sdmo_aload;
   output sdmo_bdrive; 
   reg sdmo_bdrive;
   output sdmo_hready; 
   reg sdmo_hready;
   output sdmo_hsel; 
   reg sdmo_hsel;
   output sdmo_bsel; 
   reg sdmo_bsel;
   output[1:0] sdmo_hresp; 
   reg[1:0] sdmo_hresp;

   parameter WPROTEN = (wprot != 0); 
   parameter SDINVCLK = (invclk != 0); 
   parameter BUS64 = (sdbits == 64); 
   parameter[1:0] midle = 0; 
   parameter[1:0] active = 1; 
   parameter[1:0] leadout = 2; 
   parameter[4:0] act1 = 0; 
   parameter[4:0] act2 = 1; 
   parameter[4:0] act3 = 2; 
   parameter[4:0] rd1 = 3; 
   parameter[4:0] rd2 = 4; 
   parameter[4:0] rd3 = 5; 
   parameter[4:0] rd4 = 6; 
   parameter[4:0] rd5 = 7; 
   parameter[4:0] rd6 = 8; 
   parameter[4:0] rd7 = 9; 
   parameter[4:0] rd8 = 10; 
   parameter[4:0] wr1 = 11; 
   parameter[4:0] wr2 = 12; 
   parameter[4:0] wr3 = 13; 
   parameter[4:0] wr4 = 14; 
   parameter[4:0] wr5 = 15; 
   parameter[4:0] sidle = 16; 
   parameter[2:0] iidle = 0; 
   parameter[2:0] pre = 1; 
   parameter[2:0] ref_ = 2; //ref is a key word of sv 2005
   parameter[2:0] lmode = 3; 
   parameter[2:0] finish = 4; 
   // sdram configuration register
   // local registers
   // only needed to keep address lines from switch too much
   reg r_hready; 
   reg r_hsel; 
   reg r_bdrive; 
   reg r_burst; 
   reg r_busy; 
   reg r_bdelay; 
   reg r_wprothit; 
   reg r_startsd; 
   reg r_aload; 
   reg[1:0] r_mstate; 
   reg[4:0] r_sdstate; 
   reg[1:0] r_cmstate; 
   reg[2:0] r_istate; 
   reg[2:0] r_icnt; 
   reg[1:0] r_cfg_command; 
   reg[1:0] r_cfg_csize; 
   reg[2:0] r_cfg_bsize; 
   reg r_cfg_casdel; 
   reg[2:0] r_cfg_trfc; 
   reg r_cfg_trp; 
   reg[14:0] r_cfg_refresh; 
   reg r_cfg_renable; 
   reg r_cfg_pageburst; 
   reg[2:0] r_trfc; 
   reg[14:0] r_refresh; 
   reg[1:0] r_sdcsn; 
   reg r_sdwen; 
   reg r_rasn; 
   reg r_casn; 
   reg[7:0] r_dqm; 
   reg r_bsel; 
   reg[16:2] r_address; 
   reg ri_hready; 
   reg ri_hsel; 
   reg ri_bdrive; 
   reg ri_burst; 
   reg ri_busy; 
   reg ri_bdelay; 
   reg ri_wprothit; 
   reg ri_startsd; 
   reg ri_aload; 
   reg[1:0] ri_mstate; 
   reg[4:0] ri_sdstate; 
   reg[1:0] ri_cmstate; 
   reg[2:0] ri_istate; 
   reg[2:0] ri_icnt; 
   reg[1:0] ri_cfg_command; 
   reg[1:0] ri_cfg_csize; 
   reg[2:0] ri_cfg_bsize; 
   reg ri_cfg_casdel; 
   reg[2:0] ri_cfg_trfc; 
   reg ri_cfg_trp; 
   reg[14:0] ri_cfg_refresh; 
   reg ri_cfg_renable; 
   reg ri_cfg_pageburst; 
   reg[2:0] ri_trfc; 
   reg[14:0] ri_refresh; 
   reg[1:0] ri_sdcsn; 
   reg ri_sdwen; 
   reg ri_rasn; 
   reg ri_casn; 
   reg[7:0] ri_dqm; 
   reg ri_bsel; 
   reg[16:2] ri_address; 

   always @(*)
   begin : ctrl
      reg startsd; 
      reg[31:0] haddr; 
      reg[31:0] regsd; // data from registers
      reg[7:0] dqm; 
      reg[12:0] raddr; 
      reg adec; 
      reg busy; 
      reg aload; 
      reg[1:0] rams; 
      reg[1:0] hresp; 
      reg[1:0] ba; 
      reg[2:0] lline; 
      reg[2:0] rline; 
      reg lineburst; 
      // Variable default settings to avoid latches
      //v = r;
      ri_hready=r_hready; 
      ri_hsel=r_hsel; 
      ri_bdrive=r_bdrive; 
      ri_burst=r_burst; 
      ri_busy=r_busy; 
      ri_bdelay=r_bdelay; 
      ri_wprothit=r_wprothit; 
      ri_startsd=r_startsd; 
      ri_aload=r_aload; 
      ri_mstate=r_mstate; 
      ri_sdstate=r_sdstate; 
      ri_cmstate=r_cmstate; 
      ri_istate=r_istate; 
      ri_icnt=r_icnt; 
      ri_cfg_command=r_cfg_command; 
      ri_cfg_csize=r_cfg_csize; 
      ri_cfg_bsize=r_cfg_bsize; 
      ri_cfg_casdel=r_cfg_casdel; 
      ri_cfg_trfc=r_cfg_trfc; 
      ri_cfg_trp=r_cfg_trp; 
      ri_cfg_refresh=r_cfg_refresh; 
      ri_cfg_renable=r_cfg_renable; 
      ri_cfg_pageburst=r_cfg_pageburst; 
      ri_trfc=r_trfc; 
      ri_refresh=r_refresh; 
      ri_sdcsn=r_sdcsn; 
      ri_sdwen=r_sdwen; 
      ri_rasn=r_rasn; 
      ri_casn=r_casn; 
      ri_dqm=r_dqm; 
      ri_bsel=r_bsel; 
      ri_address=r_address;
     
      startsd = 1'b0; 
      ri_busy = 1'b0; 
      hresp = HRESP_OKAY; 
      lline = {~r_cfg_casdel, r_cfg_casdel, r_cfg_casdel}; 
      rline = {~r_cfg_casdel, r_cfg_casdel, r_cfg_casdel}; 
      if (sdi_hready == 1'b1)
      begin
         ri_hsel = sdi_hsel; 
      end 
      if ((sdi_hready & sdi_hsel) == 1'b1)
      begin
         if ((sdi_htrans[1]) == 1'b1)
         begin
            ri_hready = 1'b0; 
         end 
      end 
      if (fast == 1)
      begin
         haddr = sdi_rhaddr; 
      end
      else
      begin
         haddr = sdi_haddr; 
      end 
      if ((pageburst == 0) | ((pageburst == 2) & r_cfg_pageburst == 1'b0))
      begin
         lineburst = 1'b1; 
      end
      else
      begin
         lineburst = 1'b0; 
      end 
      case (sdi_hsize)
         2'b00 :
                  begin
                     // main state
                     case (sdi_rhaddr[1:0])
                        2'b00 :
                                 begin
                                    dqm = 8'b11110111; 
                                 end
                        2'b01 :
                                 begin
                                    dqm = 8'b11111011; 
                                 end
                        2'b10 :
                                 begin
                                    dqm = 8'b11111101; 
                                 end
                        default :
                                 begin
                                    dqm = 8'b11111110; 
                                 end
                     endcase 
                  end
         2'b01 :
                  begin
                     if ((sdi_rhaddr[1]) == 1'b0)
                     begin
                        dqm = 8'b11110011; 
                     end
                     else
                     begin
                        dqm = 8'b11111100; 
                     end 
                  end
         default :
                  begin
                     dqm = 8'b11110000; 
                  end
      endcase 
      if (BUS64 & (r_bsel == 1'b1))
      begin
         dqm = {dqm[3:0], 4'b1111}; 
      end 
      // main FSM
      case (r_mstate)
         midle :
                  begin
                     if ((ri_hsel & sdi_nhtrans[1]) == 1'b1)
                     begin
                        if ((r_sdstate == sidle) & (r_cfg_command == 2'b00) & (r_cmstate == midle) & (sdi_idle == 1'b1))
                        begin
                           if (fast == 1)
                           begin
                              ri_startsd = 1'b1; 
                           end
                           else
                           begin
                              startsd = 1'b1; 
                           end 
                           ri_mstate = active; 
                        end 
                     end 
                  end
         default :
                  begin
                  end
      endcase 
      startsd = r_startsd | startsd; 
      // generate row and column address size
      case (r_cfg_csize)
         2'b00 :
                  begin
                     raddr = haddr[22:10]; 
                  end
         2'b01 :
                  begin
                     raddr = haddr[23:11]; 
                  end
         2'b10 :
                  begin
                     raddr = haddr[24:12]; 
                  end
         default :
                  begin
                     if (r_cfg_bsize == 3'b111)
                     begin
                        raddr = haddr[26:14]; 
                     end
                     else
                     begin
                        raddr = haddr[25:13]; 
                     end 
                  end
      endcase 
      // generate bank address
      //ba = {genmux(r_cfg_bsize, haddr[28:21]), genmux(r_cfg_bsize, haddr[27:20])}; 
      ba = {haddr[r_cfg_bsize+21],haddr[r_cfg_bsize+20]}; 
      // generate chip select
      if (BUS64)
      begin
         //adec = genmux(r_cfg_bsize, haddr[30:23]); 
         //ri_bsel = genmux(r_cfg_bsize, sdi_rhaddr[29:22]); 
         adec = haddr[r_cfg_bsize+23]; 
         ri_bsel = sdi_rhaddr[r_cfg_bsize+22]; 
      end
      else
      begin
         //adec = genmux(r_cfg_bsize, haddr[29:22]); 
         adec = haddr[r_cfg_bsize+22]; 
         ri_bsel = 1'b0; 
      end 
      if ((sdi_srdis == 1'b0) & (r_cfg_bsize == 3'b111))
      begin
         adec = ~adec; 
      end 
      rams = {adec, ~adec}; 
      if (r_trfc != 3'b000)
      begin
         ri_trfc = r_trfc - 1; 
      end 
      // sdram access FSM
      case (r_sdstate)
         sidle :
                  begin
                     ri_bdelay = 1'b0; 
                     if ((startsd == 1'b1) & (r_cfg_command == 2'b00) & (r_cmstate == midle))
                     begin
                        ri_address[16:2] = {ba, raddr}; 
                        ri_sdcsn = ~rams[1:0]; 
                        ri_rasn = 1'b0; 
                        ri_sdstate = act1; 
                        ri_startsd = 1'b0; 
                     end 
                  end
         act1 :
                  begin
                     ri_rasn = 1'b1; 
                     ri_trfc = r_cfg_trfc; 
                     if (r_cfg_casdel == 1'b1)
                     begin
                        ri_sdstate = act2; 
                     end
                     else
                     begin
                        ri_sdstate = act3; 
                        ri_hready = sdi_hwrite & sdi_htrans[0] & sdi_htrans[1]; 
                     end 
                     if (WPROTEN)
                     begin
                        ri_wprothit = wpo_wprothit; 
                        if (wpo_wprothit == 1'b1)
                        begin
                           hresp = HRESP_ERROR; 
                        end 
                     end 
                  end
         act2 :
                  begin
                     ri_sdstate = act3; 
                     ri_hready = sdi_hwrite & sdi_htrans[0] & sdi_htrans[1]; 
                     if (WPROTEN & (r_wprothit == 1'b1))
                     begin
                        hresp = HRESP_ERROR; 
                        ri_hready = 1'b0; 
                     end 
                  end
         act3 :
                  begin
                     ri_casn = 1'b0; 
                     ri_address[14:2] = {sdi_rhaddr[13:12], 1'b0, sdi_rhaddr[11:2]}; 
                     ri_dqm = dqm; 
                     ri_burst = r_hready; 
                     if (sdi_hwrite == 1'b1)
                     begin
                        ri_sdstate = wr1; 
                        ri_sdwen = 1'b0; 
                        ri_bdrive = 1'b1; 
                        if (sdi_htrans == 2'b11 | (r_hready == 1'b0))
                        begin
                           ri_hready = 1'b1; 
                        end 
                        if (WPROTEN & (r_wprothit == 1'b1))
                        begin
                           hresp = HRESP_ERROR; 
                           ri_hready = 1'b1; 
                           ri_sdstate = wr1; 
                           ri_sdwen = 1'b1; 
                           ri_bdrive = 1'b0; 
                           ri_casn = 1'b1; 
                        end 
                     end
                     else
                     begin
                        ri_sdstate = rd1; 
                     end 
                  end
         wr1 :
                  begin
                     ri_address[14:2] = {sdi_rhaddr[13:12], 1'b0, sdi_rhaddr[11:2]}; 
                     if ((((r_burst & r_hready) == 1'b1) & (sdi_rhtrans == 2'b11)) & ~(WPROTEN & (r_wprothit == 1'b1)))
                     begin
                        ri_hready = sdi_htrans[0] & sdi_htrans[1] & r_hready; 
                        if ((sdi_rhaddr[5:2] == 4'b1111) & (r_cfg_command == 2'b10))
                        begin
                           // exit on refresh
                           ri_hready = 1'b0; 
                        end 
                     end
                     else
                     begin
                        ri_sdstate = wr2; 
                        ri_bdrive = 1'b0; 
                        ri_casn = 1'b1; 
                        ri_sdwen = 1'b1; 
                        ri_dqm = {8{1'b1}}; 
                     end 
                  end
         wr2 :
                  begin
                     if (r_trfc[2:1] == 2'b00)
                     begin
                        if (r_cfg_trp == 1'b0)
                        begin
                           ri_rasn = 1'b0; 
                           ri_sdwen = 1'b0; 
                        end 
                        ri_sdstate = wr3; 
                     end 
                  end
         wr3 :
                  begin
                     if (r_cfg_trp == 1'b1)
                     begin
                        ri_rasn = 1'b0; 
                        ri_sdwen = 1'b0; 
                        ri_sdstate = wr4; 
                     end
                     else
                     begin
                        ri_sdcsn = 2'b11; 
                        ri_rasn = 1'b1; 
                        ri_sdwen = 1'b1; 
                        if (r_trfc == 3'b000)
                        begin
                           ri_sdstate = sidle; 
                        end 
                     end 
                  end
         wr4 :
                  begin
                     ri_sdcsn = 2'b11; 
                     ri_rasn = 1'b1; 
                     ri_sdwen = 1'b1; 
                     if (r_cfg_trp == 1'b1)
                     begin
                        ri_sdstate = wr5; 
                     end
                     else
                     begin
                        if (r_trfc == 3'b000)
                        begin
                           ri_sdstate = sidle; 
                        end 
                     end 
                  end
         wr5 :
                  begin
                     if (r_trfc == 3'b000)
                     begin
                        ri_sdstate = sidle; 
                     end 
                  end
         rd1 :
                  begin
                     ri_casn = 1'b1; 
                     ri_sdstate = rd7; 
                     if (lineburst & (sdi_htrans == 2'b11))
                     begin
                        if (sdi_rhaddr[4:2] == 3'b111)
                        begin
                           ri_address[9:5] = r_address[9:5] + 1; 
                           ri_address[4:2] = 3'b000; 
                           ri_casn = 1'b0; 
                        end 
                     end 
                  end
         rd7 :
                  begin
                     ri_casn = 1'b1; 
                     if (r_cfg_casdel == 1'b1)
                     begin
                        ri_sdstate = rd2; 
                        if (lineburst & (sdi_htrans == 2'b11))
                        begin
                           if (sdi_rhaddr[4:2] == 3'b110)
                           begin
                              ri_address[9:5] = r_address[9:5] + 1; 
                              ri_address[4:2] = 3'b000; 
                              ri_casn = 1'b0; 
                           end 
                        end 
                     end
                     else
                     begin
                        ri_sdstate = rd3; 
                        if (sdi_htrans != 2'b11)
                        begin
                           if (r_trfc[2:1] == 2'b00)
                           begin
                              ri_rasn = 1'b0; 
                              ri_sdwen = 1'b0; 
                           end 
                        end
                        else if (lineburst)
                        begin
                           if (sdi_rhaddr[4:2] == 3'b110)
                           begin
                              ri_address[9:5] = r_address[9:5] + 1; 
                              ri_address[4:2] = 3'b000; 
                              ri_casn = 1'b0; 
                           end 
                        end 
                     end 
                  end
         rd2 :
                  begin
                     ri_casn = 1'b1; 
                     ri_sdstate = rd3; 
                     if (sdi_htrans != 2'b11)
                     begin
                        ri_rasn = 1'b0; 
                        ri_sdwen = 1'b0; 
                     end
                     else if (lineburst)
                     begin
                        if (sdi_rhaddr[4:2] == 3'b101)
                        begin
                           ri_address[9:5] = r_address[9:5] + 1; 
                           ri_address[4:2] = 3'b000; 
                           ri_casn = 1'b0; 
                        end 
                     end 
                     if (ri_sdwen == 1'b0)
                     begin
                        ri_dqm = {8{1'b1}}; 
                     end 
                  end
         rd3 :
                  begin
                     ri_sdstate = rd4; 
                     ri_hready = 1'b1; 
                     ri_casn = 1'b1; 
                     if (r_sdwen == 1'b0)
                     begin
                        ri_rasn = 1'b1; 
                        ri_sdwen = 1'b1; 
                        ri_sdcsn = 2'b11; 
                        ri_dqm = {8{1'b1}}; 
                     end
                     else if (lineburst & (sdi_htrans == 2'b11) & (r_casn == 1'b1))
                     begin
                        if (sdi_rhaddr[4:2] == ({2'b10, ~r_cfg_casdel}))
                        begin
                           ri_address[9:5] = r_address[9:5] + 1; 
                           ri_address[4:2] = 3'b000; 
                           ri_casn = 1'b0; 
                        end 
                     end 
                  end
         rd4 :
                  begin
                     ri_hready = 1'b1; 
                     ri_casn = 1'b1; 
                     if ((sdi_htrans != 2'b11) | (r_sdcsn == 2'b11) | ((sdi_rhaddr[5:2] == 4'b1111) & (r_cfg_command == 2'b10)))
                     begin
                        // exit on refresh
                        ri_hready = 1'b0; 
                        ri_dqm = {8{1'b1}}; 
                        if (r_sdcsn != 2'b11)
                        begin
                           ri_rasn = 1'b0; 
                           ri_sdwen = 1'b0; 
                           ri_sdstate = rd5; 
                        end
                        else
                        begin
                           if (r_cfg_trp == 1'b1)
                           begin
                              ri_sdstate = rd6; 
                           end
                           else
                           begin
                              ri_sdstate = sidle; 
                           end 
                        end 
                     end
                     else if (lineburst)
                     begin
                        if ((sdi_rhaddr[4:2] == lline) & (r_casn == 1'b1))
                        begin
                           ri_address[9:5] = r_address[9:5] + 1; 
                           ri_address[4:2] = 3'b000; 
                           ri_casn = 1'b0; 
                        end 
                     end 
                  end
         rd5 :
                  begin
                     if (r_cfg_trp == 1'b1)
                     begin
                        ri_sdstate = rd6; 
                     end
                     else
                     begin
                        ri_sdstate = sidle; 
                     end 
                     ri_sdcsn = {2{1'b1}}; 
                     ri_rasn = 1'b1; 
                     ri_sdwen = 1'b1; 
                     ri_dqm = {8{1'b1}}; 
                     ri_casn = 1'b1; 
                  end
         rd6 :
                  begin
                     ri_sdstate = sidle; 
                     ri_dqm = {8{1'b1}}; 
                     ri_sdcsn = {2{1'b1}}; 
                     ri_rasn = 1'b1; 
                     ri_sdwen = 1'b1; 
                  end
         default :
                  begin
                     ri_sdstate = sidle; 
                  end
      endcase 
      case (r_cmstate)
         midle :
                  begin
                     if (r_sdstate == sidle)
                     begin
                        // sdram commands
                        case (r_cfg_command)
                           2'b01 :
                                    begin
                                       // precharge
                                       if (sdi_idle == 1'b1)
                                       begin
                                          ri_busy = 1'b1; 
                                          ri_sdcsn = {2{1'b0}}; 
                                          ri_rasn = 1'b0; 
                                          ri_sdwen = 1'b0; 
                                          ri_address[12] = 1'b1; 
                                          ri_cmstate = active; 
                                       end 
                                    end
                           2'b10 :
                                    begin
                                       // auto-refresh
                                       ri_sdcsn = {2{1'b0}}; 
                                       ri_rasn = 1'b0; 
                                       ri_casn = 1'b0; 
                                       ri_cmstate = active; 
                                    end
                           2'b11 :
                                    begin
                                       if (sdi_idle == 1'b1)
                                       begin
                                          ri_busy = 1'b1; 
                                          ri_sdcsn = {2{1'b0}}; 
                                          ri_rasn = 1'b0; 
                                          ri_casn = 1'b0; 
                                          ri_sdwen = 1'b0; 
                                          ri_cmstate = active; 
                                          if (lineburst)
                                          begin
                                             ri_address[15:2] = {9'b000010001, r_cfg_casdel, 4'b0011}; 
                                          end
                                          else
                                          begin
                                             ri_address[15:2] = {9'b000010001, r_cfg_casdel, 4'b0111}; 
                                          end 
                                       end 
                                    end
                           default :
                                    begin
                                    end
                        endcase 
                     end 
                  end
         active :
                  begin
                     ri_sdcsn = {2{1'b1}}; 
                     ri_rasn = 1'b1; 
                     ri_casn = 1'b1; 
                     ri_sdwen = 1'b1; 
                     ri_cfg_command = 2'b00; 
                     ri_cmstate = leadout; 
                     ri_trfc = r_cfg_trfc; 
                  end
         leadout :
                  begin
                     if (r_trfc == 3'b000)
                     begin
                        ri_cmstate = midle; 
                     end 
                  end
      endcase 
      // sdram init
      case (r_istate)
         iidle :
                  begin
                     if ((sdi_idle & sdi_enable) == 1'b1)
                     begin
                        ri_cfg_command = 2'b01; 
                        ri_istate = pre; 
                     end 
                  end
         pre :
                  begin
                     if (r_cfg_command == 2'b00)
                     begin
                        ri_cfg_command = 2'b10; 
                        ri_istate = ref_; 
                        ri_icnt = 3'b111; 
                     end 
                  end
         ref_ :
                  begin
                     if (r_cfg_command == 2'b00)
                     begin
                        ri_cfg_command = 2'b10; 
                        ri_icnt = r_icnt - 1; 
                        if (r_icnt == 3'b000)
                        begin
                           ri_istate = lmode; 
                           ri_cfg_command = 2'b11; 
                        end 
                     end 
                  end
         lmode :
                  begin
                     if (r_cfg_command == 2'b00)
                     begin
                        ri_istate = finish; 
                     end 
                  end
         default :
                  begin
                     if (sdi_enable == 1'b0)
                     begin
                        ri_istate = iidle; 
                     end 
                  end
      endcase 
      if ((sdi_hready & sdi_hsel) == 1'b1)
      begin
         if ((sdi_htrans[1]) == 1'b0)
         begin
            ri_hready = 1'b1; 
         end 
      end 
      // second part of main fsm
      case (r_mstate)
         active :
                  begin
                     if (ri_hready == 1'b1)
                     begin
                        ri_mstate = midle; 
                     end 
                  end
         default :
                  begin
                  end
      endcase 
      if ((r_cfg_renable == 1'b1) & (r_istate == finish))
      begin
         ri_refresh = r_refresh - 1; 
         // sdram refresh counter
         if ((ri_refresh[14] & ~r_refresh[14]) == 1'b1)
         begin
            ri_refresh = r_cfg_refresh; 
            ri_cfg_command = 2'b10; 
         end 
      end 
      if ((apbi_psel[pindex] & apbi_penable & apbi_pwrite) == 1'b1)
      begin
         case (apbi_paddr[3:2])
            2'b01 :
                     begin
                        // APB register access
                        if (pageburst == 2)
                        begin
                           ri_cfg_pageburst = apbi_pwdata[17]; 
                        end 
                        if (sdi_enable == 1'b1)
                        begin
                           ri_cfg_command = apbi_pwdata[20:19]; 
                        end 
                        ri_cfg_csize = apbi_pwdata[22:21]; 
                        ri_cfg_bsize = apbi_pwdata[25:23]; 
                        ri_cfg_casdel = apbi_pwdata[26]; 
                        ri_cfg_trfc = apbi_pwdata[29:27]; 
                        ri_cfg_trp = apbi_pwdata[30]; 
                        ri_cfg_renable = apbi_pwdata[31]; 
                     end
            2'b10 :
                     begin
                        ri_cfg_refresh = apbi_pwdata[26:12]; 
                        ri_refresh = {15{1'b0}}; 
                     end
            default :
                     begin
                     end
         endcase 
      end 
      regsd = {32{1'b0}}; 
      case (apbi_paddr[3:2])
         2'b01 :
                  begin
                     regsd[31:19] = {r_cfg_renable, r_cfg_trp, r_cfg_trfc, r_cfg_casdel, r_cfg_bsize, r_cfg_csize, r_cfg_command}; 
                     if (~lineburst)
                     begin
                        regsd[17] = 1'b1; 
                     end 
                  end
         default :
                  begin
                     regsd[26:12] = r_cfg_refresh; 
                  end
      endcase 
      //apbo_prdata <= regsd ; 
      apbo_prdata = regsd ; 
      if (fast == 0)
      begin
         // synchronise with sram/prom controller
         if ((r_sdstate < wr4) | (ri_hsel == 1'b1))
         begin
            ri_busy = 1'b1; 
         end 
      end
      else
      begin
         if ((r_sdstate < wr4) | (r_startsd == 1'b1))
         begin
            ri_busy = 1'b1; 
         end 
      end 
      ri_busy = ri_busy | r_bdelay; 
      busy = ri_busy | r_busy; 
      ri_aload = r_busy & ~ri_busy; 
      aload = ri_aload; 
      // generate memory address
      //sdmo_address <= ri_address ; 
      sdmo_address = ri_address ; 
      if (rst == 1'b0)
      begin
         ri_sdstate = sidle; 
         ri_mstate = midle; 
         ri_istate = iidle; 
         ri_cmstate = midle; 
         ri_hsel = 1'b0; 
         ri_cfg_command = 2'b00; 
         ri_cfg_csize = 2'b10; 
         ri_cfg_bsize = 3'b000; 
         ri_cfg_casdel = 1'b1; 
         ri_cfg_trfc = 3'b111; 
         ri_cfg_renable = 1'b0; 
         ri_cfg_trp = 1'b1; 
         ri_dqm = {8{1'b1}}; 
         ri_sdwen = 1'b1; 
         ri_rasn = 1'b1; 
         ri_casn = 1'b1; 
         ri_hready = 1'b1; 
         ri_startsd = 1'b0; 
         // reset
         if (pageburst == 2)
         begin
            ri_cfg_pageburst = 1'b0; 
         end 
      end 
      //ri <= v ; 
       
      sdmo_bdrive = ri_bdrive ; 
      sdo_sdcke = {2{1'b1}} ; 
      sdo_sdcsn = r_sdcsn ; 
      sdo_sdwen = r_sdwen ; 
      sdo_dqm = r_dqm ; 
      sdo_rasn = r_rasn ; 
      sdo_casn = r_casn ; 
      sdmo_busy = busy ; 
      sdmo_aload = aload ; 
      sdmo_hready = r_hready ; 
      sdmo_hresp = hresp ; 
      sdmo_hsel = r_hsel ; 
      sdmo_bsel = r_bsel ; 
   end 

   always @(posedge clk)
   begin : regs
      {r_hready, r_hsel, r_bdrive, r_burst, r_busy, r_bdelay, r_wprothit, r_startsd,
      r_aload, r_mstate, r_sdstate, r_cmstate, r_istate, r_icnt, r_cfg_command, r_cfg_csize,
      r_cfg_bsize, r_cfg_casdel, r_cfg_trfc, r_cfg_trp, r_cfg_refresh, r_cfg_renable, r_cfg_pageburst,
      r_trfc, r_refresh, r_sdcsn, r_sdwen, r_rasn, r_casn, r_dqm, r_bsel, r_address}<=
      {ri_hready, ri_hsel, ri_bdrive, ri_burst, ri_busy, ri_bdelay, ri_wprothit, ri_startsd,
      ri_aload, ri_mstate, ri_sdstate, ri_cmstate, ri_istate, ri_icnt, ri_cfg_command, ri_cfg_csize,
      ri_cfg_bsize, ri_cfg_casdel, ri_cfg_trfc, ri_cfg_trp, ri_cfg_refresh, ri_cfg_renable, ri_cfg_pageburst,
      ri_trfc, ri_refresh, ri_sdcsn, ri_sdwen, ri_rasn, ri_casn, ri_dqm, ri_bsel, ri_address} ; 
      if (rst == 1'b0)
      begin
         r_icnt <= {3{1'b0}} ; 
      end  
      if (rst == 1'b0)
      begin
         r_bdrive <= 1'b0 ; 
         r_sdcsn <= {2{1'b1}} ; 
      end 
   end 
endmodule
